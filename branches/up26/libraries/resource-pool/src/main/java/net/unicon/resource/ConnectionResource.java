/*
 * Copyright (C) 2007 Unicon, Inc.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this distribution.  It is also available here:
 * http://www.fsf.org/licensing/licenses/gpl.html
 *
 * As a special exception to the terms and conditions of version
 * 2 of the GPL, you may redistribute this Program in connection
 * with Free/Libre and Open Source Software ("FLOSS") applications
 * as described in the GPL FLOSS exception.  You should have received
 * a copy of the text describing the FLOSS exception along with this
 * distribution.
 */
package net.unicon.resource;

import net.unicon.resource.util.ErrorUtils;

import java.sql.*;
import java.util.Map;

class ConnectionResource extends Resource implements Connection {
    protected String simpleSQL;

    ConnectionResource(ResourcePool pool, String requester, Object rawResourceID, Object rawResource, String simpleSQL) {
        super(pool, requester, rawResourceID, rawResource);
        this.simpleSQL = simpleSQL;
    }

    protected Connection connection() {
        return (Connection) rawResource;
    }

    @Override
    protected String getRawResourceName() {
        return "Connection";
    }

    @Override
    protected String getTypeName() {
        return "ConnectionResource";
    }

    @Override
    void copyFrom(Resource otherResource) {
        super.copyFrom(otherResource);

        ConnectionResource otherConnectionResource = (ConnectionResource) otherResource;
        simpleSQL = otherConnectionResource.simpleSQL;
    }

    @Override
    boolean verify() throws Exception {
        Statement refreshStatement = null;
        ResultSet rs = null;
        try {
            refreshStatement = connection().createStatement();
            if (simpleSQL != null && simpleSQL.length() > 0) {
                rs = refreshStatement.executeQuery(simpleSQL);
                rs.next();
            }
        } catch (Exception e) {
            // ERROR
            ErrorUtils.swallow(e);
            return false;
        } finally {
            if (rs != null) {
                rs.close();
            }
            if (refreshStatement != null) {
                refreshStatement.close();
            }
        }

        lastUseTime = System.currentTimeMillis();
        return true;
    }

    @Override
    void refresh() throws Exception {
        if (!verify()) {
            throw new Exception("Raw Resource cannot be refreshed");
        }
    }

    @Override
    void recycle() throws Exception {
        super.recycle();
	if (!connection().getAutoCommit()) {
	    connection().rollback();
	}
    }

    @Override
    void destroy() throws Exception {
        super.destroy();
        connection().close();
    }

    public Statement createStatement() throws SQLException {
        checkActive();
        Statement answer = connection().createStatement();
        answer = new StatementComponent(this, answer);
        return answer;
    }

    public PreparedStatement prepareStatement(String sql) throws SQLException {
        checkActive();
        PreparedStatement answer = connection().prepareStatement(sql);
        answer = new PreparedStatementComponent(this, answer, sql);
        return answer;
    }

    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public CallableStatement prepareCall(String sql) throws SQLException {
        checkActive();
        CallableStatement answer = connection().prepareCall(sql);
        answer = new CallableStatementComponent(this, answer);
        return answer;
    }

    public String nativeSQL(String sql) throws SQLException {
        checkActive();
        return connection().nativeSQL(sql);
    }

    public void setAutoCommit(boolean autoCommit) throws SQLException {
        checkActive();
        connection().setAutoCommit(autoCommit);
    }

    public boolean getAutoCommit() throws SQLException {
        checkActive();
        return connection().getAutoCommit();
    }

    public void close() throws SQLException {
    	if(!isClosed()){
	        checkActive();
	        pool.release(this);
    	}
    }

    public void commit() throws SQLException {
        checkActive();
        connection().commit();
    }

    public void rollback() throws SQLException {
        checkActive();
        connection().rollback();
    }

    public void rollback(Savepoint savepoint) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public boolean isClosed() throws SQLException {
        if(connection() != null)
        	return connection().isClosed();
        return true;
    }

    public int getHoldability() throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public Savepoint setSavepoint() throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public Savepoint setSavepoint(String name) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public void setHoldability(int holdability) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public DatabaseMetaData getMetaData() throws SQLException {
        checkActive();
        DatabaseMetaData answer = connection().getMetaData();
        answer = new DatabaseMetaDataComponent(this, answer);
        return answer;
    }

    public void setReadOnly(boolean readonly) throws SQLException {
        checkActive();
        connection().setReadOnly(readonly);
    }

    public boolean isReadOnly() throws SQLException {
        checkActive();
        return connection().isReadOnly();
    }

    public void setCatalog(String catalog) throws SQLException {
        checkActive();
        connection().setCatalog(catalog);
    }

    public String getCatalog() throws SQLException {
        checkActive();
        return connection().getCatalog();
    }

    public void setTransactionIsolation(int level) throws SQLException {
        checkActive();
        connection().setTransactionIsolation(level);
    }

    public int getTransactionIsolation() throws SQLException {
        checkActive();
        return connection().getTransactionIsolation();
    }

    public SQLWarning getWarnings() throws SQLException {
        checkActive();
        return connection().getWarnings();
    }

    public void clearWarnings() throws SQLException {
        checkActive();
        connection().clearWarnings();
    }

    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        checkActive();
        Statement answer = connection().createStatement(resultSetType, resultSetConcurrency);
        answer = new StatementComponent(this, answer);
        return answer;
    }

    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        checkActive();
        PreparedStatement answer = connection().prepareStatement(sql, resultSetType, resultSetConcurrency);
        answer = new PreparedStatementComponent(this, answer, sql);
        return answer;
    }

    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        checkActive();
        CallableStatement answer = connection().prepareCall(sql, resultSetType, resultSetConcurrency);
        answer = new CallableStatementComponent(this, answer);
        return answer;
    }

    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        throw new UnsupportedOperationException(UNSUPPORTED_MESSAGE);
    }

    public Map<String, Class<?>> getTypeMap() throws SQLException {
        checkActive();
        return connection().getTypeMap();
    }

    public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
        checkActive();
        connection().setTypeMap(map);
    }

    private final static String UNSUPPORTED_MESSAGE = "This operation will not be supported until all of UNICON's developers are using JDK 1.4.0";
}
